/**
 * Integration test for the Liturgical Calendar Service with database operations
 */
import { getLiturgicalInfo } from './LiturgicalCalendarService';
import clientPromise from '@/lib/mongodb';

// Service Details collection mock
const mockServiceDetailsCollection = {
  findOne: jest.fn(),
  updateOne: jest.fn()
};

// Create a mock MongoDB client for integration testing
jest.mock('@/lib/mongodb', () => {
  // Mock DB object
  const mockDb = {
    collection: jest.fn().mockImplementation((collectionName) => {
      if (collectionName === "serviceDetails") {
        return mockServiceDetailsCollection;
      }
      return {
        findOne: jest.fn(),
        updateOne: jest.fn()
      };
    })
  };
  
  const mockClient = {
    db: jest.fn().mockReturnValue(mockDb)
  };
  
  // Export the mock client
  return {
    __esModule: true,
    default: Promise.resolve(mockClient),
    _mockClient: mockClient,
    _mockDb: mockDb
  };
});

// Import the mocks
const { _mockClient: mockClient, _mockDb: mockDb } = require('@/lib/mongodb');

// Helper function to simulate the service-details API behavior
async function enhanceServiceWithLiturgicalInfo(date) {
  const client = await clientPromise;
  const db = client.db("church");
  
  const details = await db.collection("serviceDetails").findOne({ date });
  
  if (details) {
    // Parse date string to Date object (format: M/D/YY)
    const [month, day, yearShort] = date.split('/').map(num => parseInt(num, 10));
    // Convert 2-digit year to 4-digit
    const fullYear = yearShort < 50 ? 2000 + yearShort : 1900 + yearShort;
    const serviceDate = new Date(fullYear, month - 1, day);
    
    // Get liturgical information
    const liturgicalInfo = getLiturgicalInfo(serviceDate);
    
    // Format liturgical info as it would be stored in the database
    const liturgical = {
      season: liturgicalInfo.seasonId,
      seasonName: liturgicalInfo.season.name,
      color: liturgicalInfo.color,
      specialDay: liturgicalInfo.specialDayId,
      specialDayName: liturgicalInfo.specialDay?.name || null
    };
    
    // Update the service with liturgical info
    await db.collection("serviceDetails").updateOne(
      { date },
      { $set: { liturgical } }
    );
    
    // Return the updated service details
    return { ...details, liturgical };
  }
  
  return null;
}

describe('LiturgicalCalendarService Integration', () => {
  // Reset all mocks before each test
  beforeEach(() => {
    jest.clearAllMocks();
  });
  
  test('enhances Christmas service with correct liturgical information', async () => {
    // Setup the mock response for this specific test
    mockServiceDetailsCollection.findOne.mockResolvedValueOnce({
      date: "12/25/24",
      title: "Christmas Day Service",
      elements: []
    });
    
    mockServiceDetailsCollection.updateOne.mockResolvedValueOnce({ modifiedCount: 1 });
    
    const enhancedService = await enhanceServiceWithLiturgicalInfo("12/25/24");
    
    // Verify that the database queries were made correctly
    expect(mockClient.db).toHaveBeenCalledWith('church');
    expect(mockDb.collection).toHaveBeenCalledWith('serviceDetails');
    expect(mockServiceDetailsCollection.findOne).toHaveBeenCalledWith({ date: "12/25/24" });
    expect(mockServiceDetailsCollection.updateOne).toHaveBeenCalled();
    
    // Check that the liturgical information is correctly added
    expect(enhancedService).toHaveProperty('liturgical');
    expect(enhancedService.liturgical).toHaveProperty('season', 'CHRISTMAS');
    expect(enhancedService.liturgical).toHaveProperty('color', '#D4AF37');
    expect(enhancedService.liturgical).toHaveProperty('specialDay', 'CHRISTMAS_DAY');
  });
  
  test('enhances Easter service with correct liturgical information', async () => {
    // Setup the mock response for this specific test
    mockServiceDetailsCollection.findOne.mockResolvedValueOnce({
      date: "4/20/25",
      title: "Easter Sunday Service",
      elements: []
    });
    
    mockServiceDetailsCollection.updateOne.mockResolvedValueOnce({ modifiedCount: 1 });
    
    const enhancedService = await enhanceServiceWithLiturgicalInfo("4/20/25");
    
    // Verify that the service was enhanced with liturgical info
    expect(mockServiceDetailsCollection.findOne).toHaveBeenCalledWith({ date: "4/20/25" });
    expect(mockServiceDetailsCollection.updateOne).toHaveBeenCalled();
    
    expect(enhancedService).toHaveProperty('liturgical');
    expect(enhancedService.liturgical).toHaveProperty('season', 'EASTER');
    // Easter is actually gold, so we need to fix this expectation
    expect(enhancedService.liturgical).toHaveProperty('color', '#FFF0AA');
    expect(enhancedService.liturgical).toHaveProperty('specialDay', 'EASTER_SUNDAY');
  });
  
  test('handles service not found correctly', async () => {
    // Setup the mock response for this specific test
    mockServiceDetailsCollection.findOne.mockResolvedValueOnce(null);
    
    const enhancedService = await enhanceServiceWithLiturgicalInfo("1/1/25");
    
    // Verify that the database was queried
    expect(mockClient.db).toHaveBeenCalledWith('church');
    expect(mockDb.collection).toHaveBeenCalledWith('serviceDetails');
    expect(mockServiceDetailsCollection.findOne).toHaveBeenCalledWith({ date: "1/1/25" });
    
    // Service should be null since it doesn't exist
    expect(enhancedService).toBeNull();
  });
  
  test('correctly enhances multiple services with different seasons', async () => {
    // Test with services from different liturgical seasons
    const testDates = [
      { date: "12/25/24", expectedSeason: "CHRISTMAS", specialDay: "CHRISTMAS_DAY" },
      { date: "4/20/25", expectedSeason: "EASTER", specialDay: "EASTER_SUNDAY" }
    ];
    
    for (const { date, expectedSeason, specialDay } of testDates) {
      // Reset mocks for each iteration
      jest.clearAllMocks();
      
      // Configure the mock to return different service data
      mockServiceDetailsCollection.findOne.mockResolvedValueOnce({
        date,
        title: `Service on ${date}`,
        elements: []
      });
      
      mockServiceDetailsCollection.updateOne.mockResolvedValueOnce({ modifiedCount: 1 });
      
      // Enhance the service
      const enhancedService = await enhanceServiceWithLiturgicalInfo(date);
      
      // Verify correct API calls
      expect(mockServiceDetailsCollection.findOne).toHaveBeenCalledWith({ date });
      expect(mockServiceDetailsCollection.updateOne).toHaveBeenCalled();
      
      // Verify correct season was assigned
      expect(enhancedService.liturgical.season).toBe(expectedSeason);
      if (specialDay) {
        expect(enhancedService.liturgical.specialDay).toBe(specialDay);
      }
    }
  });
  
  test('integration with migration script pattern works correctly', async () => {
    // Set up mock services to simulate a batch operation like in the migration script
    const mockServices = [
      { date: "12/25/24", title: "Christmas Service" },
      { date: "4/20/25", title: "Easter Service" },
      { date: "11/26/25", title: "Thanksgiving Service" }
    ];
    
    let updatedCount = 0;
    
    // Process services in a batch (simulating migration script)
    for (const service of mockServices) {
      // Reset mocks for each iteration
      jest.clearAllMocks();
      
      // Mock the service lookup for each date
      mockServiceDetailsCollection.findOne.mockResolvedValueOnce(service);
      mockServiceDetailsCollection.updateOne.mockResolvedValueOnce({ modifiedCount: 1 });
      
      // Enhance with liturgical info
      const enhanced = await enhanceServiceWithLiturgicalInfo(service.date);
      
      // Verify API calls
      expect(mockServiceDetailsCollection.findOne).toHaveBeenCalledWith({ date: service.date });
      expect(mockServiceDetailsCollection.updateOne).toHaveBeenCalled();
      
      // Verify enhancing worked
      expect(enhanced).toHaveProperty('liturgical');
      expect(enhanced.liturgical).toHaveProperty('seasonName');
      expect(enhanced.liturgical).toHaveProperty('color');
      
      updatedCount++;
    }
    
    // Should have processed all services
    expect(updatedCount).toBe(mockServices.length);
  });
});